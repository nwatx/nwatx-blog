---
author: nwatx
title: AtCoder DP Editorial
description: A quick editorial for all the problems contained in the AtCoder DP Contest
tags: code, c++, algorithms, dynamic programming
date: 2021-04-22
---

<Warning title="This article is a work in progress" description="Many more problems need to be added. If you would like to contribute, feel free to contact me."/>

# Introduction

This post contains the editorials for all of the tasks contained in the [AtCoder DP Contest](https://atcoder.jp/contests/dp/tasks), since there is no official editorial.

## Frog 1

We can use a Breadth-First Search to search through all the possible moves of the frog. Whenever a distance $d$ squares away from the frog's current location can be reduced through $\texttt{dp}[top] + |c[top+d]-c[top]| < \texttt{dp}[top+d]$, we reduce it and add it to our queue. Squares are only visited at most twice, so the time complexity is $\mathcal{O}(N)$.

```cpp
int dp[mx];
int c[mx];

int main() {
	setIO();
    ints(n);

    F0R(i, n) cin >> c[i+1];
    F0R(i, mx) dp[i] = MOD;

    queue<int> bfs;
    bfs.push(1);
    dp[1] = 0;
    while(sz(bfs)) {
        int top = bfs.front();
        bfs.pop();
        // dbg(top);

        if(top + 1 <= n && dp[top] + abs(c[top+1] - c[top]) < dp[top+1]) {
            bfs.push(top+1);
            ckmin(dp[top+1], dp[top] + abs(c[top+1] - c[top]));
        }

        if(top + 2 <= n && dp[top] + abs(c[top+2] - c[top]) < dp[top+2]) {
            bfs.push(top+2);
            ckmin(dp[top+2], dp[top] + abs(c[top+2] - c[top]));
        }
    }

    ps(dp[n]);
}
```

## Frog 2

This is the exact same problem as Frog 1, just with variable distances. Since our previous approach keeps track of such distances, we can simply reuse the code, just changing one line to account for the new variable $K$.

```cpp
const int mx = 2e5+1;

int dp[mx];
int c[mx];

int main() {
	setIO();
    ints(n, k);

    F0R(i, n) cin >> c[i+1];
    F0R(i, mx) dp[i] = MOD;

    queue<int> bfs;
    bfs.push(1);
    dp[1] = 0;
    while(sz(bfs)) {
        int top = bfs.front();
        bfs.pop();
        // dbg(top);

		FOR(i, 1, k+1) {
			if(top + i <= n && dp[top] + abs(c[top+i] - c[top]) < dp[top+i]) {
				bfs.push(top+i);
				ckmin(dp[top+i], dp[top] + abs(c[top+i] - c[top]));
			}
		}
    }

    ps(dp[n]);
}
```

## Vacation

Since Taro can't do the activities for two or more consecutive days, we can instead use $\texttt{dp}[i][j]$ as the $i$-th day that ends on activity $j$. Hence, the best we can do for any day $A$ is either the previous best for day $B +$ the happiness attained from $C$, or day $C +$ the happiness attained from $B$. The same goes for days $B, C$. In this sense, our formulation is: 

$$
\texttt{dp}[i][j] = \max_{k \neq j} dp[i-1][k] + V[d] : d \neq j, k
$$

```cpp
const int mx = 2e5+1;

int dp[mx][3];

int main() {
	setIO();

    int n; re(n);
    FOR(i, 1, n+1){
        ints(a, b, c);
        ckmax(dp[i][0], max(dp[i-1][1] + b, dp[i-1][2] + c));
        ckmax(dp[i][1], max(dp[i-1][0] + a, dp[i-1][2] + c));
        ckmax(dp[i][2], max(dp[i-1][0] + a, dp[i-1][1] + b));
    }

    ps(max(dp[n][0], max(dp[n][1], dp[n][2])));
}
```

## Knapsack 1

This is the classical knapsack problem. Notice that because $v=10^9$, it is not feasible to store $v$. Instead, we can store the possible values of $W \le 10^5$. In other words, $\texttt{dp}[i][j]$ represents the maximum value that can be attained by the first $i$ weights with a weight of $j$. Other than that, this is the classical [knapsack problem](https://usaco.guide/CPH.pdf#page=82).

```cpp
const int mx = 2e5+1;

ll dp[101][mx];
int W[101], A[101];

int main() {
	setIO();

    ints(n, w);
	F0R(i, n) re(W[i], A[i]);

	F0R(i, n) {
		F0R(j, w+1) {
			if(j + W[i] <= w) {
				ckmax(dp[i+1][j+W[i]], dp[i][j] + A[i]);
			}
			ckmax(dp[i+1][j], dp[i][j]);
		}
	}

	ps(dp[n][w]);
}
```

## Knapsack 2

This is the exact same problem except instead of a high value of $v$, there is a high value of $W$. Now, we must minimize the value of $W$ for any given $v$, and then try to find out the maximum value of $v$ that can be reached.

```cpp:fancyAlert.cpp
function fancyAlert(arg) {
  if (arg) {
    $.facebox({ div: '#foo' })
  }
}
```

```cpp
const int mx = 2e5+1;

int W[mx], v[mx]; // notice that v is smaller, minimize W!
ll dp[mx]; // stores the minimum weight with value j

int main() {
	setIO();

    ints(n, w);

    F0R(i, n) re(W[i], v[i]);
    F0R(i, mx) dp[i] = INF;

    dp[0] = 0;

    F0R(i, n) {
        R0F(j, 100001) {
            if(dp[j] + W[i] <= w) ckmin(dp[j + v[i]], dp[j] + W[i]);
        }
    }

    int ret = 0;
    F0R(i, 100001) if(dp[i] != INF) ckmax(ret, i);
    ps(ret);
}
```