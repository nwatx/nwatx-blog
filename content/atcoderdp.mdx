---
title: AtCoder DP Editorial
author: Neo Wang, Dong Liu
description: A quick editorial for all the problems contained in the AtCoder DP Contest
tags: code, c++, algorithms, dynamic programming
date: 2021-04-22
---

# Introduction

This post contains the editorials for tasks A-E contained in the
[AtCoder DP Contest](https://atcoder.jp/contests/dp/tasks), since there is no
official editorial.

# Solutions

## [A - Frog 1](https://atcoder.jp/contests/dp/tasks/dp_a)

**Time Complexity:** $\mathcal{O}(N)$

Use dynamic programming and define $\texttt{dp}[i]$ as the minimum cost to reach
stone $i$. Then, there are only two transitions:

- Jump one stone:

  $$
  \texttt{dp}[i + 1] = \min(\texttt{dp}[i + 1], \texttt{dp}[i] + |\texttt{A}[i] - \texttt{A}[i + 1]|)
  $$

- Jump two stones:
  $$
  \texttt{dp}[i + 2] = \min_{0 \le i + j < N}(\texttt{dp}[i + 2], \texttt{dp}[i] + |\texttt{A}[i] - \texttt{A}[i + 2]|)
  $$

```cpp
#include <bits/stdc++.h>

using namespace std;

const int mx = 1e5+1;

int A[mx], dp[mx];

int main() {
	cin.tie(0)->sync_with_stdio(0);

	int N; cin >> N;

	for(int i = 0; i < N; i++) {
		cin >> A[i];
		dp[i] = 1e9 + 7;
	}

	dp[0] = 0;

	for(int i = 0; i < N; i++) {
		if(i + 1 < N) dp[i + 1] = min(dp[i + 1], dp[i] + abs(A[i] - A[i+1]));
		if(i + 2 < N) dp[i + 2] = min(dp[i + 2], dp[i] + abs(A[i] - A[i+2]));
	}

	cout << dp[N - 1] << endl;
}
```

## [B - Frog 2](https://atcoder.jp/contests/dp/tasks/dp_b)

**Time Complexity:** $\mathcal{O}(NK)$

This is the exact same problem as Frog 1, just with variable distances. Simply
loop through each of the possible jumps, and use the previous transition where
$\texttt{dp}[i]$ represents the best value for stone $i$.

$$
\texttt{dp}[i + j] = \min_{0 \le i + j < N}(\texttt{dp}[i + j], \texttt{dp}[i] + |\texttt{A}[i] - \texttt{A}[i + j]|)
$$

```cpp
#include <bits/stdc++.h>

using namespace std;

const int mx = 1e5+1;

int A[mx], dp[mx];

int main() {
	cin.tie(0)->sync_with_stdio(0);

	int N, K; cin >> N >> K;

	for(int i = 0; i < N; i++) {
		cin >> A[i];
		dp[i] = 1e9 + 7;
	}

	dp[0] = 0;

	for(int i = 0; i < N; i++) {
		for(int j = 1; j <= K; j++) { // j is jump
			if(i + j < N) dp[i + j] = min(dp[i + j], dp[i] + abs(A[i] - A[i + j]));
		}
	}

	cout << dp[N - 1] << endl;
}
```

## [C - Vacation](https://atcoder.jp/contests/dp/tasks/dp_c)

**Time Complexity:** $\mathcal{O}(N)$

Since Taro can't do the activities for two or more consecutive days, we can
instead define $\texttt{dp}[i][j]$ as the best possible value on the $i$-th day
that ends on activity $j$. Hence, the best we can do for any day $A$ is either
the previous best ending on day $B$ added to the happiness attained from $C$, or
the previous best ending on day $C$ added to the happiness attained from $B$.
The same goes for days $B, C$. In this sense, our formulation is:

$$
\texttt{dp}[i][j] = \max_{k \neq j}(dp[i-1][k] + V[d] : d \neq j, d \neq k)
$$

```cpp
#include <bits/stdc++.h>

using namespace std;

const int mx = 1e5+1;

bool ckmax(int& a, const int& b) {
	return a < b ? a = b, 1 : 0;
}

int dp[mx][3];

int main() {
	cin.tie(0)->sync_with_stdio(0);

	int N; cin >> N;

	for(int i = 1; i <= N; i++) {
		int a, b, c; cin >> a >> b >> c;
		ckmax(dp[i][0], max(dp[i-1][1] + b, dp[i-1][2] + c));
		ckmax(dp[i][1], max(dp[i-1][0] + a, dp[i-1][2] + c));
		ckmax(dp[i][2], max(dp[i-1][0] + a, dp[i-1][1] + b));
	}

	cout << max(dp[N][0], max(dp[N][1], dp[N][2])) << endl;
}
```

## [D - Knapsack 1](https://atcoder.jp/contests/dp/tasks/dp_d)

**Time Complexity:** $\mathcal{O}(NW)$

This is the classical knapsack problem. Notice that because $v_i \le 10^9$, it
is not feasible to store $v_i$ in our $\texttt{dp}$ array. Instead, store the
possible values of $W (W \le 10^5)$. Let $\texttt{dp}[i][j]$ represent the
maximum value that can be attained by the first $i$ weights with a weight of
$j$. Then, this turns into the classical
[knapsack problem](https://usaco.guide/CPH.pdf#page=82).

```cpp
#include <bits/stdc++.h>

using namespace std;

const int mx = 1e5+1;

template<class T> bool ckmax(T& a, const T& b) {
	return a < b ? a = b, 1 : 0;
}

long long dp[101][mx];
int w[101], v[101];

int main() {
	cin.tie(0)->sync_with_stdio(0);

	int N, W; cin >> N >> W;
	for(int i = 0; i < N; i++) cin >> w[i] >> v[i];

	for(int i = 0; i < N; i++) for(int j = 0; j <= W; j++) {
		if(j + w[i] <= W) ckmax(dp[i + 1][j + w[i]], dp[i][j] + v[i]);
		ckmax(dp[i + 1][j], dp[i][j]);
	}

	cout << dp[N][W] << endl;
}
```

## [E - Knapsack 2](https://atcoder.jp/contests/dp/tasks/dp_e)

**Time Complexity:** $\mathcal{O}(N^2V)$

This is the exact same problem except instead of a high value of $v_i$, there is
a high value of $w_i$. Now, we must minimize the value of $w_i$ for any given
$v_i$, and then try to find out the maximum value of $v_i$ that can be reached.

Define $\texttt{dp}[i]$ as the lowest weight we can achieve for value $i$. The
transition then, is:

$$
\texttt{dp}[j + \texttt{v}[i]] = \min (\texttt{dp}[j + \texttt{v}[i]],\texttt{dp}[j] + \texttt{w}[i])
$$

```cpp
#include <bits/stdc++.h>

using namespace std;

const int mx = 1e5+1;

template<class T> bool ckmin(T& a, const T& b) {
	return a > b ? a = b, 1 : 0;
}

long long dp[mx];
int w[101], v[101];

int main() {
	cin.tie(0)->sync_with_stdio(0);

	int N, W; cin >> N >> W;
	for(int i = 0; i < N; i++) cin >> w[i] >> v[i];
	for(int i = 0; i < mx; i++) dp[i] = 1e18;

	dp[0] = 0;

	for(int i = 0; i < N; i++) {
		for(int j = mx - 1; j >= 0; j--) {
			if(dp[j] + w[i] <= W) ckmin(dp[j + v[i]], dp[j] + w[i]);
		}
	}

	for(int i = mx - 1; i >= 0; i--) {
		if(dp[i] != 1e18) {
			cout << i << endl;
			break;
		}
	}
}
```

## [F - LCS](https://atcoder.jp/contests/dp/tasks/dp_f)

**Time Complexity:** $\mathcal{O}(N^2)$

First read [this](https://usaco.guide/gold/paths-grids?lang=cpp), then following
the according $\texttt{dp}$ model, build the string accordingly.

```cpp
#include <bits/stdc++.h>

using namespace std;

template<class T> bool ckmax(T& a, const T& b) {
	return a < b ? a = b, 1 : 0;
}

int dp[3001][3001];

int main() {
	cin.tie(0)->sync_with_stdio(0);
	string s, t; cin >> s >> t;
	int n = s.size(), m = t.size();

	for(int i = 0 ; i <= n; i++) {
		for(int j = 0; j <= m; j++)  {
			if(!i || !j) dp[i][j] = 0;
			else if(s[i - 1] == t[j - 1]) dp[i][j] = 1 + dp[i - 1][j - 1];
			else dp[i][j] = max(dp[i - 1][j],dp[i][j - 1]);
		}
	}

	string ret = "";

	while(n && m) {
		if(s[n - 1] == t[m - 1]) {
			ret += s[n - 1];
			n--;
			m--;
		}
		else if(dp[n - 1][m] > dp[n][m - 1]) n--;
		else m--;
	 }

	 reverse(ret.begin(), ret.end());

	 cout << ret << endl;
}
```

## [G - Longest Path](https://atcoder.jp/contests/dp/tasks/dp_g)

**Time Complexity:** $\mathcal{O}(N + M)$

Simply perform a DFS on the graph, defining $\texttt{dp}[i]$ as the longest path that
node $i$ can take. Notice how the optimal substructure is formed: the best path for
any node $x$ is one added to the best path for any of its children.

```cpp
#include <bits/stdc++.h>

using namespace std;

vector<int> dp(100001);
vector<vector<int>> adj(100001);

int dfs(int x) {
	if (dp[x]) return dp[x];
	for (auto e : adj[x]){
			dp[e] = dfs(e);
			dp[x] = max(dp[e] + 1, dp[x]);
	}
	return dp[x];
}

int main(){
	int n,m;
	cin >> n >> m;
	
	for(int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		a--; b--;
		adj[a].push_back(b);
	}

	for (int i = 0; i < n; i++) {
		dfs(i);
	}

	int ans = 0;

	for (int i = 0;i < n; i++) {
		ans = max(dp[i], ans);
	}

	cout << ans;
}
```

## [H - Grid 1](https://atcoder.jp/contests/dp/tasks/dp_h)

**Time Complexity:** $\mathcal{O}(N^2)$

A full tutorial can be found
[here](https://usaco.guide/gold/paths-grids?lang=cpp#tutorial).

```cpp
#include <bits/stdc++.h>

using namespace std;

bool ok[1000][1000];
long long dp[1000][1000];

int main() {
	cin.tie(0)->sync_with_stdio(0);

	int n; cin >> n;
	for(int i = 0; i < n; i++) {
		string s;
		cin >> s;
		for(int j = 0; j < n; j++) {
			if(s[j] == '.') ok[i][j] = true;
			else ok[i][j] = false;
		}
	}

	dp[0][0] = 1;
	for(int i = 0; i < n; i++) {
		for(int j = 0; j < n; j++) {
			if(!ok[i][j]) dp[i][j] = 0;
			else {
				if(i > 0) dp[i][j] += dp[i - 1][j];
				if(j > 0) dp[i][j] += dp[i][j - 1];
				dp[i][j] %= 1000000007;
			}
		}
	}

	cout << dp[n - 1][n - 1] << "\n";

	return 0;
}
```

## [I - Coins](https://atcoder.jp/contests/dp/tasks/dp_i)

**Time Complexity:** $\mathcal{O}(N^2)$

Define $\texttt{dp}[i][j]$ to be the probability after tossing the first $i$
coins, and receiving $j$ heads. Then, our probability of flipping $j$ heads from
the first $i$ coins is the addition of the following:

- either we flipped a head with probability $p$
  - then use $$\texttt{dp}[i-1][j-1]$$, the probability of receiving $j-1$ heads
    from the previous toss.
- we flipped a tail with probability $1-p$
  - then use $\texttt{dp}[i-1][j]\cdot(1-\texttt{p}[i-1])$, the probability of
    receiving $j$ heads from the previous toss.

$$
\texttt{dp}[i][j] = \texttt{dp}[i-1][j-1]\cdot \texttt{p}[i-1] + \texttt{dp}[i-1][j]\cdot(1-\texttt{p}[i-1])
$$

```cpp
#include<bits/stdc++.h>

using namespace std;

long double dp[3001][3001];

int main() {
	cin.tie(0)->sync_with_stdio(0);

	int n;
	cin >> n;

	vector<long double> p(n);

	for(int i = 0; i < n; i++) cin >> p[i];

	int leastHeads = n / 2 + 1;

	for(int i = 0; i <= n; i++) {
			dp[i][0] = 1;
	}

	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= leastHeads; j++) {
			dp[i][j] = dp[i - 1][j - 1] * p[i - 1] + dp[i - 1][j] * (1 - p[i - 1]);
		}
	}

	cout << fixed << setprecision(10) << dp[n][leastHeads] << endl;
}
```

## [J - Sushi](https://atcoder.jp/contests/dp/tasks/dp_j)

**Time Complexity:** $\mathcal{O}(N^3)$

Let $\texttt{dp}[x][y][z]$ represent the expected moves for
$x$ number of plates 1-sushi remaining, $y$ number of plates
2-sushi remaining, $z$ number of plates 3-sushi remaining.

Then, we can use the relation

$$
\texttt{dp}[x][y][z] = n + x \cdot \texttt{dp}[x-1][y][z]
												+ y \cdot \texttt{dp}[x+1][y-1][z]
												+ z \cdot \texttt{dp}[x][y+1][z-1]
$$

Note that we add $1$ for the $y$ and $z$ equations because
we take from one sushi platter which transitions into one
more sushi in another grouping of either $x,y$. For example,
by taking one sushi away from a group of size $2$ then there is a
corresponding increase in a sushi group of size $1$.

```cpp
#include <bits/stdc++.h>

using namespace std;

int n;

long double dp[301][301][301];
// let dp[i][j][k] be
// i dishes of 1 sushi
// j dishes of 2 sushi
// k dishes of 3 sushi

double memo(int x, int y, int z) {
	if(x < 0 || y < 0 || z < 0) return 0;
	if(x == 0 && y == 0 && z == 0) return 0;
	// if(x + y + z < 1) return 0;
	if(dp[x][y][z] > 0) return dp[x][y][z];

	long double ret = n + x * memo(x - 1, y, z)  // # 1 sushi
					+ y * memo(x + 1, y - 1, z)  // # 2 sushi
					+ z * memo(x, y + 1, z - 1); // # 3 sushi

	return dp[x][y][z] = ret / (x + y + z);
}

int main() {
	cin.tie(0)->sync_with_stdio(0);

	cin >> n;
	vector<int> a(n); for(int i = 0; i < n; i++) cin >> a[i];

	vector<int> freq(3);
	for(int x : a) freq[x-1]++; 

	memset(dp, -1, sizeof dp);

	cout << fixed << setprecision(10) << memo(freq[0], freq[1], freq[2]) << endl;
}
```

## [K - Stones](https://atcoder.jp/contests/dp/tasks/dp_k)

Define $\texttt{dp}[i]$ as if it's possible to win with $i$ stones remaining.
Then keep two loops, one for values of $i (1 \le i \le K)$, and the other for
each value in $A$. If $i \ge j$ and it was not possible to win a game with
$i - a_j$ stones, then - because the turns alternate - a game with $i$ stones
is winnable.

```
#include <bits/stdc++.h>
using namespace std;

int main() {
	cin.tie(0)->sync_with_stdio(0);

	int n, k;
	cin >> n >> k;
	vector<int> a(n);
	for (int& x : a) cin >> x;
	vector<bool> dp(k + 1);
	for (int i = 1; i <= k; i++)
		for (int j : a)
			if (i >= j && !dp[i - j])
				dp[i] = 1;
	cout << (dp[k] ? "First" : "Second") << '\n';
}
```

## [L - Deque](https://atcoder.jp/contests/dp/tasks/dp_l)

Define $\texttt{dp}[i][j]$ as the optimal score for Jiro $(X - Y)$
using the range $[i, j]$. Then, we can either choose $a_i$
to append to the left of the range, or $a_j$ on the right. Then,
our two transitions are

$$
\texttt{dp}[i][j] = \max_{j > i}
\left\{\begin{matrix}
a_i - \texttt{dp}[i+1][j] \\ 
a_j - \texttt{dp}[i][j-1]
\end{matrix}\right.
$$

Our initial states $\texttt{dp}_[i][i] = 0$, since any range of size $0$
will have difference $0$

```cpp
#include <bits/stdc++.h>
using namespace std;

long long dp[3001][3001];
	
int main() {
	cin.tie(0)->sync_with_stdio(0);
	
	int n;
	cin >> n;

	vector<int> a(n);
	for (int& x : a) cin >> x;

	for (int i = 0; i < n; ++i) dp[i][i] = a[i];

	for (int i = n - 1; i >= 0; i--)
		for (int j = i + 1; j < n; j++)
			dp[i][j] = max(a[i] - dp[i + 1][j], a[j] - dp[i][j - 1]);
	cout << dp[0][n - 1] << '\n';
}
```

## [M - Candies](https://atcoder.jp/contests/dp/tasks/dp_m)

```cpp
#include <bits/stdc++.h>
using namespace std;
	
const int MAXK = 100000;
const int MOD = 1000000007;
	
int add(int i, int j) {
	if ((i += j) >= MOD)
		i -= MOD;
	return i;
}
	
int sub(int i, int j) {
	if ((i -= j) < 0)
		i += MOD;
	return i;
}
	
int main() {
	cin.tie(0)->sync_with_stdio(0);
	
	int n, k, a;
	cin >> n >> k;
	
	static int dp[MAXK + 1], dq[MAXK + 1];
	dp[0] = 1;
	for (int i = 1; i <= n; ++i) {
		cin >> a;
		for (int j = 1; j <= k; ++j)
			dp[j] = add(dp[j - 1], dp[j]);
		for (int j = 0; j <= k; ++j)
			dq[j] = sub(dp[j], (j > a ? dp[j - a - 1] : 0));
		swap(dp, dq);
	}
	cout << dp[k] << '\n';
}
```

## [O - Matching](https://atcoder.jp/contests/dp/tasks/dp_o)

**Time Complexity:** $\mathcal{O}(N\cdot 2^N)$

If we define $\texttt{dp}[S]$ to be the number of matchings for females in the
set $S$ to the first $|S|$ males, this problem boils down to the following:

$$
\texttt{dp}[S] = \sum \texttt{dp}[S\backslash x]:  \texttt{compatible}[|S|][x]
$$

(The `:` stands for "such that".)
In English, this is equivalent to the following:

> The number of matchings in a subset $S$ to include a certain female $x$ is
> equivalent to the sum of all the matchings without female $x$ where female $x$
> is compatible with the $|S|$-th male.

Our base case is the empty set, which has a value of $1$ (the empty set can be
considered as a single matching involving zero pairs).
	
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MOD = 1e9 + 7;
const int MAX_N = 21;

bool compat[MAX_N][MAX_N];
int dp[1 << MAX_N];

int main() {
	int N;
	cin >> N;
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < N; j++) {
			cin >> compat[i][j];
		}
	}

	dp[0] = 1;

	for (int s = 0; s < (1 << N); s++) {
		int pair_num = __builtin_popcount(s);
		for (int w = 0; w < N; w++) {
			/*
			 * check that
			 * 1. this woman hasn't been paired already
			 * 2. she's also compatible with the {pair_num + 1}th man
			 */
			if ((s & (1 << w)) || !compat[pair_num][w])
				continue;
			
			// add the amount to future dp states
			dp[s | (1 << w)] += dp[s];
			dp[s | (1 << w)] %= MOD;
		}
	}

   	cout << dp[(1 << N) - 1] << endl;
}
```