---
title: Everything you need to know for the UIL computer science exam
description: From bit operations to data structures, this guide should tackle almost every subtype of the UIL computer science exam.
tags: bit operations, code, math, UIL
date: 2021-03-28
author: nwatx
---

<NextImage
  src="https://res.cloudinary.com/dcg5b3jpt/image/upload/v1616909831/blog/UIL-logo_tmeblz.jpg"
  height={400}
  width={800}
/>

# Introduction

The UIL computer science exam is a _45-minute written exam for an individual and team component, as well as a two-hour programming contest for teams._ Because the advancement criteria is only the top 3 spots, it is critical for winners to achieve as high a score as possible. Unfortunately, the exam is given in Java, which means most of studying time should be reading through the documentation and intracicies of the Java programming language. Since most of the "easy" problems are easy to do and understand, we will instead discuss most of the advanced tricks and patterns that are encountered on the UIL computer science exam.

## Things you should know before diving into this article

Before reading this article, it's important to gain a general understanding of computer science otherwise the following topics presented may be difficult to understand.

<Pros
  title="Things that you should already know"
  pros={[
	"An AP Computer Science understanding of Java",
	"The basics of bit operations (what they do)",
	"Basic knowledge of what a tree is",
  ]}
/>

If you don't know any of these materials, you can use the following resources to get started:

- [Progamiz - General Java](https://www.programiz.com/java-programming)
- [GeeksForGeeks - Bitwise operators](https://www.geeksforgeeks.org/bitwise-operators-in-java/)
- [Wikipedia - Binary Search Tree](https://en.wikipedia.org/wiki/Binary_search_tree)

Furthermore, you should be somewhat exposed to the following data structures:

<Pros
  title="Data structures you should be familiar with"
  pros={[
	"ArrayList",
	"Array",
	"LinkedList",
	"Trees (in general)",
	"Binary Search Trees",
	"Queue",
	"PriorityQueue",
	"Stack",
  ]}
/>

and the following algorithms:

<Pros
  title="Algorithms you should be familiar with"
  pros={[
	"Sorting (general)",
	"Binary Search",
	"Brute force (general)",
	"Complete search (general)",
  ]}
/>

as well as the concept of [inheritance](https://www.programiz.com/java-programming/inheritance).

# Primitive Operations

<Problem choices={['3.0', '3', '4', '4.0']} answer='3.0' explanation="Since all of the operators are of equal precedence, simply evaluate this expression from left to right.">

What is the output of `out.println(12/4.0*5/5)`

</Problem>

- The four basic operations `+,-,/,*` and `%` can be performed from any of type `int, char, double, long, etc...` to each other without erroring.

- When performing operations on characters, perform a conversion of `char->int` before applying any operations. Recall that the ASCII values for `0, A, a` are $48$, $65$, and $97$ respectively.

# Sorting Operations

<Problem answer="Bubble Sort" explanation="A huge giveaway is the use of the method swap.">

What is sorting algorithm is this?

```java
public static void sort(Comparable[] data) {
	int temp;
	int len = data.length;
	for(int i = 0; i < len - 1; i++) {
		temp = i;
		for(int j = i + 1; j < len; j++) {
			if (/* filled in correctly */) {
				temp = j;
			}
		}
		swap(data, i, temp);
	}
}
```

</Problem>

For whatever reason, UIL requires the knowledge of suboptimal $\mathcal{O}(N^2)$ sorting operations. Here are common implementations (provided by [G4G](https://www.geeksforgeeks.org/)) and descriptions for the common ones:

## Bubble Sort

Description: Repeatedly swaps adjacent elements if they are in the wrong order.

Worst case complexity: $\mathcal{O}(N^2)$.

Best case complexity: $\mathcal{O}(N)$.


```java
void bubbleSort(int arr[]) {
	int n = arr.length;
	for (int i = 0; i < n-1; i++) {
		for (int j = 0; j < n-i-1; j++) {
			if (arr[j] > arr[j+1]) {
				// swap arr[j+1] and arr[j]
				int temp = arr[j];
				arr[j] = arr[j+1];
				arr[j+1] = temp;
			}
		}
	}
}
```

## Insertion Sort

Description: Split into a sorted and unsorted part: think how you sort cards.

Worst case complexity: $\mathcal{O}(N^2)$.

Best case complexity: $\mathcal{O}(N)$.

```java
void sort(int arr[])
{
	int n = arr.length;
	for (int i = 1; i < n; ++i) {
		int key = arr[i];
		int j = i - 1;

		/* Move elements of arr[0..i-1], that are
			greater than key, to one position ahead
			of their current position */
		while (j >= 0 && arr[j] > key) {
			arr[j + 1] = arr[j];
			j = j - 1;
		}
		arr[j + 1] = key;
	}
}
```

## Insertion Sort

Description: Repeatedly finds the minimum element from unsorted part and putting it at the beginning.

Worst case complexity: $\mathcal{O}(N^2)$.

Best case complexity: $\mathcal{O}(N)$.

```java
void sort(int arr[]) {
	int n = arr.length;
	for (int i = 1; i < n; ++i) {
		int key = arr[i];
		int j = i - 1;

		/* Move elements of arr[0..i-1], that are
			greater than key, to one position ahead
			of their current position */
		while (j >= 0 && arr[j] > key) {
			arr[j + 1] = arr[j];
			j = j - 1;
		}
		arr[j + 1] = key;
	}
}
```

## Selection Sort

Description: Repeatedly finds the minimum element from unsorted part and puts it at the beginning of the sorted part.

Worst case complexity: $\mathcal{O}(N^2)$.

Best case complexity: $\mathcal{O}(N^2)$.

```java
void sort(int arr[]) {
	int n = arr.length;

	// One by one move boundary of unsorted subarray
	for (int i = 0; i < n-1; i++) {
		// Find the minimum element in unsorted array
		int min_idx = i;
		for (int j = i+1; j < n; j++) {
			if (arr[j] < arr[min_idx]) {
				min_idx = j;
			}
		}

		// Swap the found minimum element with the first
		// element
		int temp = arr[min_idx];
		arr[min_idx] = arr[i];
		arr[i] = temp;
	}
}
```

# Operator Precedence

This is a big one to know; at least 3 problems are based off this on every exam. You can use the acronym PUMA BS CE BLTA to memorize this order 

1. **PUMA:** postfix, unary, multiplicative, additive)
2. **BS:** bit shifts.
3. **C:** comparison operators.
4. **E:** equality operators.
5. **B:** bitwise operations.
6. **L:** logic.
7. **T:** ternary.
8. **A:** assignment.

Which corresponds to the following expanded form:

1. postfix `a++, a--`
2. unary `++a, --a, +a, -a, ~, !`
3. multiplicative `* / %`
4. additive `+ -`
5. bit shifts
6. comparison operators and `instance of`.
7. equality operators
8. bitwise `&`
9. bitwise xor `^`
10. bitwise or `|`
11. logical and `&&`
12. logical or `||`
13. ternary operators
14. assignment

# Boolean algebra

Three operations you need to know: $+$ corresponds to `AND`, $\cdot$ corresponds to `OR`, $\bar{x}$ corresponds to `NOT`, and $\oplus$ corresponds to `XOR`. A list of common simplifications can be found [here](https://www.quora.com/What-are-boolean-algebra-laws)

# Tree Traversals

<Problem choices={["2 1 0 6 8", "0 1 2 6 8", "0 1 8 6 2", "2 1 6 0 8", "0 8 1 6 2"]} answer={"0 1 8 6 2"}>

The values `2,6,1,8,0` are inserted into a binary search tree using a traditional insertion. What is the result of a post order traversal of the tree?

</Problem>

`l` - left node.

`m` - middle node.

`r` - right node.

The way to memorize this is that `l` will always be visited before `r`. So, all you have to do is know where `m` is placed. Obviously, **pre**order is corresponds to `m l r`, **in**order corresponds to `l m r`, and **post**order corresponds to `l r m`.